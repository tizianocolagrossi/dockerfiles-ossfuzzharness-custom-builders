#!/bin/bash
# Convert time format (e.g., 30m → seconds, 4h → seconds)
convert_time() {
    local TIME=$1
    if [[ $TIME =~ ^([0-9]+)m$ ]]; then
        echo $((${BASH_REMATCH[1]} * 60))  # Convert minutes to seconds
    elif [[ $TIME =~ ^([0-9]+)h$ ]]; then
        echo $((${BASH_REMATCH[1]} * 3600))  # Convert hours to seconds
    else
        echo "Error: Invalid time format '$TIME'. Use 'Xm' (minutes) or 'Xh' (hours)." >&2
        exit 1
    fi
}

# Default values
TOTAL_TIMEOUT=$(convert_time "1m")  # Default 1 min
DICTIONARY=""

# Print usage message
usage() {
    echo "Usage: $0 -t <fuzz_target> -b <cpu_id> -c <corpus_zip> -o <output_dir> [-x <dictionary>] [-T <timeout>]"
    echo "  -T <timeout>: Time format can be '30m' (minutes) or '4h' (hours)"
    exit 1
}

# Parse command-line arguments
while getopts "t:b:c:o:x:d:T:" opt; do
    case ${opt} in
        t ) FUZZ_TARGET=$OPTARG ;;
        b ) CPUIDBIND=$OPTARG ;;
        c ) CORPUS_ZIP=$OPTARG ;;
        o ) OUTPUT_DIR=$OPTARG ;;
        x ) DICTIONARY=$OPTARG ;;
        T ) TOTAL_TIMEOUT=$(convert_time "$OPTARG") ;;
        * ) usage ;;
    esac
done

# Remove parsed options from positional parameters
shift $((OPTIND -1))
# Store remaining arguments
ADDITIONAL_SUT_ARGS="$@"
# Prepend " -- " if non-empty
if [[ -n $(echo "$ADDITIONAL_SUT_ARGS" | tr -d '[:space:]') ]]; then
    ADDITIONAL_SUT_ARGS="-- $ADDITIONAL_SUT_ARGS"
fi

# Ensure required arguments are provided
if [ -z "$FUZZ_TARGET" ] || [ -z "$CORPUS_ZIP" ] || [ -z "$OUTPUT_DIR" ]; then
    echo "Error: Missing required arguments!"
    usage
fi

QUEUE="$OUTPUT_DIR/default/queue/"
CRASHES="$OUTPUT_DIR/default/crashes/"

# Prepare output directories
mkdir -p "$QUEUE"
mkdir -p "$CRASHES"

# Extract corpus if ZIP exists
if [ -f "$CORPUS_ZIP" ]; then
    echo "Extracting corpus from $CORPUS_ZIP to $QUEUE..."
    unzip -o "$CORPUS_ZIP" -d "$QUEUE"
else
    echo "Error: Corpus ZIP file not found: $CORPUS_ZIP"
    exit 1
fi

append_creation_date() {
    file="$1"

    if [[ ! -f "$file" ]]; then
        echo "File does not exist: $file"
        return
    fi

    # Get creation time in epoch
    creation_epoch_formatted=$(stat -c "time:%W" "$file")
    creation_epoch=$(stat -c "%W" "$file")

    # If creation time is zero (unknown), fallback to modification time
    if [[ "$creation_epoch" -eq 0 ]]; then
        creation_epoch_formatted=$(stat -c "time:%Y" "$file")
    fi

    # Extract filename components
    filename=$(basename -- "$file")
    location=$(dirname -- "$file")
    extension="${filename##*.}"
    basename="${filename%.*}"

    # id:000002,sig:04,src:000061,time:11657035,execs:3610181,op:havoc,rep:4
    # Handle files without extension
    if [[ "$filename" == "$extension" ]]; then
        new_filename="id:${filename},sig:00,src:000000,${creation_epoch_formatted},execs:0000000,op:havoc,rep:0"
    else
        new_filename="id:${basename},sig:00,src:000000,${creation_epoch_formatted},execs:0000000,op:havoc,rep:0.${extension}"
    fi

    # Rename the file
    mv "$file" "$location/$new_filename"
    echo "Renamed to: $new_filename"
}

run_libfuzzer() {

    # # Construct command with optional dictionary
    # CMD=("$FUZZ_TARGET"
    #         -rss_limit_mb=16192 
    #         -ignore_ooms=1 
    #         -ignore_timeouts=1 
    #         -ignore_crashes=1 
    #         -print_final_stats=1
    #         -close_fd_mask=3 
    #         -timeout=5 -detect_leaks=0
    #         -max_total_time=$TOTAL_TIMEOUT
    #         -artifact_prefix=$CRASHES 
    #         )

    # # Handle additional args as an array if needed
    # if [[ -n "$ADDITIONAL_SUT_ARGS" ]]; then
    #     CMD+=($ADDITIONAL_SUT_ARGS)
    # fi

    # if [[ -n "$DICTIONARY" && -f "$DICTIONARY" ]]; then
    #     echo "Using dictionary: $DICTIONARY"
    #     CMD+=("-dict=$DICTIONARY")
    # fi

    # CMD+=("$QUEUE")

    # # Run LibFuzzer with timeout
    # echo "taskset -c $CPUIDBIND ${CMD[@]}"

    # taskset -c $CPUIDBIND "${CMD[@]}" 

    REMAINING_TIME=$TOTAL_TIMEOUT

    while (( REMAINING_TIME > 0 )); do
        # Per-run max_total_time cannot exceed remaining global budget
        RUN_TIMEOUT=$REMAINING_TIME

        CMD=("$FUZZ_TARGET"
            -rss_limit_mb=16192
            -ignore_ooms=1
            -ignore_timeouts=1
            -ignore_crashes=1
            -print_final_stats=1
            -close_fd_mask=3
            -timeout=5
            -detect_leaks=0
            -max_total_time="$RUN_TIMEOUT"
            -artifact_prefix="$CRASHES"
        )

        if [[ -n "$ADDITIONAL_SUT_ARGS" ]]; then
            CMD+=($ADDITIONAL_SUT_ARGS)
        fi

        if [[ -n "$DICTIONARY" && -f "$DICTIONARY" ]]; then
            echo "Using dictionary: $DICTIONARY"
            CMD+=("-dict=$DICTIONARY")
        fi

        CMD+=("$QUEUE")

        echo "Remaining budget: ${REMAINING_TIME}s, running with -max_total_time=${RUN_TIMEOUT}"

        SECONDS=0
        taskset -c "$CPUIDBIND" "${CMD[@]}"
        ELAPSED=$SECONDS

        # Deduct actual wall-clock from remaining global budget
        (( REMAINING_TIME -= ELAPSED ))

        echo "Run finished after ${ELAPSED}s, remaining global budget: ${REMAINING_TIME}s"

    done

    echo "Global TOTAL_TIMEOUT of ${TOTAL_TIMEOUT}s reached; stopping fuzzing."


}

echo "add args $ADDITIONAL_SUT_ARGS"

run_libfuzzer

cd $OUTPUT_DIR

for c in $CRASHES* ; do
    echo $c
    append_creation_date $c
done

tar --create --gzip --preserve-permissions --file=fuzz_out.tar.gz ./*
chown -R $OUTUID:$OUTGID $OUTPUT_DIR
ls -l
find . -not -name fuzz_out.tar.gz -delete