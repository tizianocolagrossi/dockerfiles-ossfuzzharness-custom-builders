#!/bin/bash
# Convert time format (e.g., 30m → seconds, 4h → seconds)
convert_time() {
    local TIME=$1
    if [[ $TIME =~ ^([0-9]+)m$ ]]; then
        echo $((${BASH_REMATCH[1]} * 60))  # Convert minutes to seconds
    elif [[ $TIME =~ ^([0-9]+)h$ ]]; then
        echo $((${BASH_REMATCH[1]} * 3600))  # Convert hours to seconds
    else
        echo "Error: Invalid time format '$TIME'. Use 'Xm' (minutes) or 'Xh' (hours)." >&2
        exit 1
    fi
}

# Default values
TOTAL_TIMEOUT=$(convert_time "1m")  # Default 1 min
DICTIONARY=""

# Print usage message
usage() {
    echo "Usage: $0 -t <fuzz_target> -b <cpu_id> -c <corpus_zip> -o <output_dir> [-x <dictionary>] [-T <timeout>]"
    echo "  -T <timeout>: Time format can be '30m' (minutes) or '4h' (hours)"
    exit 1
}

# Parse command-line arguments
while getopts "t:b:c:o:x:d:T:" opt; do
    case ${opt} in
        t ) FUZZ_TARGET=$OPTARG ;;
        b ) CPUIDBIND=$OPTARG ;;
        c ) CORPUS_ZIP=$OPTARG ;;
        o ) OUTPUT_DIR=$OPTARG ;;
        x ) DICTIONARY=$OPTARG ;;
        T ) TOTAL_TIMEOUT=$(convert_time "$OPTARG") ;;
        * ) usage ;;
    esac
done

# Remove parsed options from positional parameters
shift $((OPTIND -1))
# Store remaining arguments
ADDITIONAL_SUT_ARGS="$@"
# Prepend " -- " if non-empty
if [[ -n $(echo "$ADDITIONAL_SUT_ARGS" | tr -d '[:space:]') ]]; then
    ADDITIONAL_SUT_ARGS="-- $ADDITIONAL_SUT_ARGS"
fi

# Ensure required arguments are provided
if [ -z "$FUZZ_TARGET" ] || [ -z "$CORPUS_ZIP" ] || [ -z "$OUTPUT_DIR" ]; then
    echo "Error: Missing required arguments!"
    usage
fi

QUEUE="$OUTPUT_DIR/default/queue/"
CRASHES="$OUTPUT_DIR/default/crashes/"

# Prepare output directories
mkdir -p "$QUEUE"
mkdir -p "$CRASHES"

# Extract corpus if ZIP exists
if [ -f "$CORPUS_ZIP" ]; then
    echo "Extracting corpus from $CORPUS_ZIP to $QUEUE..."
    unzip -o "$CORPUS_ZIP" -d "$QUEUE"
else
    echo "Error: Corpus ZIP file not found: $CORPUS_ZIP"
    exit 1
fi

append_creation_date() {
    file="$1"

    if [[ ! -f "$file" ]]; then
        echo "File does not exist: $file"
        return
    fi

    # Get creation time in epoch
    creation_epoch_formatted=$(stat -c "time:%W" "$file")
    creation_epoch=$(stat -c "%W" "$file")

    # If creation time is zero (unknown), fallback to modification time
    if [[ "$creation_epoch" -eq 0 ]]; then
        creation_epoch_formatted=$(stat -c "time:%Y" "$file")
    fi

    # Extract filename components
    filename=$(basename -- "$file")
    location=$(dirname -- "$file")
    extension="${filename##*.}"
    basename="${filename%.*}"

    # id:000002,sig:04,src:000061,time:11657035,execs:3610181,op:havoc,rep:4
    # Handle files without extension
    if [[ "$filename" == "$extension" ]]; then
        new_filename="id:${filename},sig:00,src:000000,${creation_epoch_formatted},execs:0000000,op:havoc,rep:0"
    else
        new_filename="id:${basename},sig:00,src:000000,${creation_epoch_formatted},execs:0000000,op:havoc,rep:0.${extension}"
    fi

    # Rename the file
    mv "$file" "$location/$new_filename"
    echo "Renamed to: $new_filename"
}

run_libfuzzer() {

    # Construct command with optional dictionary
    CMD=("$FUZZ_TARGET" 
            -fork=1
            -reload=0
            -ignore_crashes=1
            -print_funcs=0
            -print_final_stats=1
            -print_corpus_stats=1
            -rss_limit_mb=16192 
            -detect_leaks=0
            -close_fd_mask=3
            -timeout=5 
            -max_total_time=$TOTAL_TIMEOUT
            -artifact_prefix=$CRASHES 
            )

    # Handle additional args as an array if needed
    if [[ -n "$ADDITIONAL_SUT_ARGS" ]]; then
        CMD+=($ADDITIONAL_SUT_ARGS)
    fi

    if [[ -n "$DICTIONARY" && -f "$DICTIONARY" ]]; then
        echo "Using dictionary: $DICTIONARY"
        CMD+=("-dict=$DICTIONARY")
    fi

    CMD+=("$QUEUE")

    # Run LibFuzzer with timeout
    echo "taskset -c $CPUIDBIND ${CMD[@]}"
    # taskset -c $CPUIDBIND "${CMD[@]}"

    # # Create the script file
    # echo "#!/bin/bash" > bashscript.sh
    # echo "${CMD[@]}" >> bashscript.sh

    # # Make it executable
    # chmod +x bashscript.sh

    OUT_FILE="$OUTPUT_DIR/default/fuzzer.log"

    # taskset -c $CPUIDBIND bashscript.sh 2>&1 | tee $OUT_FILE
    # taskset -c $CPUIDBIND "${CMD[@]}" >"$OUT_FILE" 2>&1
    taskset -c "$CPUIDBIND" "${CMD[@]}" 2>&1 | while IFS= read -r line; do
        printf '%s\n' "$line" >>"$OUT_FILE"
        tail -n 500 "$OUT_FILE" > "${OUT_FILE}.tmp" && mv "${OUT_FILE}.tmp" "$OUT_FILE"
    done


}

echo "add args $ADDITIONAL_SUT_ARGS"

run_libfuzzer

cd $OUTPUT_DIR

for c in $CRASHES* ; do
    echo $c
    append_creation_date $c
done

tar --create --gzip --preserve-permissions --file=fuzz_out.tar.gz ./*
chown -R $OUTUID:$OUTGID $OUTPUT_DIR
ls -l
find . -not -name fuzz_out.tar.gz -delete