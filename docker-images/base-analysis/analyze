#!/bin/bash

# --- Parse SUT_ARGS into pre and post "@@" parts ---
pre_testcase_args="${SUT_ARGS%% @@*}"
post_testcase_args="${SUT_ARGS##*@@ }"

# --- Constants and Environment Setup ---
export PATH=$OUT:$PATH
export AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1
export AFL_SKIP_CPUFREQ=1
export AFL_TRY_AFFINITY=1
export AFL_FAST_CAL=1
export AFL_CMPLOG_ONLY_NEW=1
export AFL_FORKSRV_INIT_TMOUT=30000
export AFL_IGNORE_PROBLEMS=1
export AFL_IGNORE_UNKNOWN_ENVS=1
# Destination directory where the symbolic links will be created
SGFUZZ_KIND=0
CRASHES=$FUZZ_OUT/crashes/
DEST_DIR="/lib/x86_64-linux-gnu/"
QUEUE_TEST_CASE=$FUZZ_OUT/queue/*
STDIN_REDIRECT=$([[ "$MULTIDESOCK" == "true" ]] && echo "true" || echo "false")

FUZZER=$1
export FUZZER=$FUZZER
shift


sysctl -w vm.mmap_rnd_bits=28
set -euo pipefail
trap 'echo "FAILED at line $LINENO"; exit 1' ERR

# --- Create symlinks for libraries ---
create_symlinks() {
  local src_dir="$1"
  for l in $src_dir/lib* ; do 
    ln -s $(realpath $l) $DEST_DIR || echo $l already present
    echo created link $l in $DEST_DIR
  done
}

create_symlinks $DEDUP_BUILD

# --- Set workdir ---
cd $OUT

# --- Unpack fuzzing output and copy stats files ---
pushd $FUZZ_OUT
if [[ -f "fuzz_out.zip" ]]; then
  unzip -o fuzz_out.zip
else
  echo "No fuzz_out.zip Exiting..."
  exit 1
fi

if [[ -f "fuzz_out.tar.gz" ]]; then
  SGFUZZ_KIND=1
  echo "Extracting fuzz_out.tar.gz..."
  tar -xzf fuzz_out.tar.gz
fi

if [ -d "./default" ]; then
    echo "AFL like output detected moved."
    QUEUE_TEST_CASE="$FUZZ_OUT/default/queue/*"
    rm -r $FUZZ_OUT/default/crashes/README.txt
    CRASHES="$FUZZ_OUT/default/crashes/"
    cp ./default/fuzzer_stats .
    cp ./default/plot_data .
fi
popd

# --- LD_PRELOAD for desockmulti if needed ---
# --- Run afltriage with multiple strategies ---

# Function to run afltriage with specified parameters
run_afltriage() {
    local strategy="$1"
    local output_dir="$FUZZ_OUT/afltriageout-$strategy"

    if [[ ! -d "$output_dir" ]]; then
        local common_args="-i $CRASHES -o $output_dir --report-formats=text,json --bucket-strategy $strategy -t 15000"
        if [ "$STDIN_REDIRECT" = "true" ]; then
            afltriage $common_args --stdin -- "$DEDUP_BUILD/$FUZZER" $SUT_ARGS
        else
            afltriage $common_args -- "$DEDUP_BUILD/$FUZZER" $pre_testcase_args @@ $post_testcase_args
        fi
    else
        echo "Skipping '$strategy': output directory exists."
    fi
}

# remember in install_deps.sh vv
# ln -s $SRC/BAAFLTriage/target/release/baafltriage /usr/local/bin/afltriage

if [ "$MULTIDESOCK" = "true" ]; then
  export LD_PRELOAD=/usr/lib/desockmulti.so
fi

# Define the bucket strategies in an array
declare -a BUCKET_STRATEGIES=("first_frame" "first_3_frames" "first_5_frames")

# Loop through each bucket strategy and call the function
for strategy in "${BUCKET_STRATEGIES[@]}"; do
    run_afltriage "$strategy"
done

unset LD_PRELOAD

# --- Coverage / Enumeration profiling ---
export ASAN_OPTIONS="detect_leaks=0"

run_testcase() {
  testcase="$1"
  fuzzer_path="$OUT/$FUZZER"
  stdin_redirect="$2"
  sut_args="$3"

  # --- Parse SUT_ARGS into pre and post "@@" parts ---
  pre_args="${sut_args%% @@*}"
  post_args="${sut_args##*@@ }"

  name=$(basename "$testcase")
  export LLVM_PROFILE_FILE="coverage_${name}.profraw"
  echo "Running testcase: $name"

  if [[ "$stdin_redirect" == "true" ]]; then
    timeout 5s $fuzzer_path $sut_args < $testcase 
  else
    timeout 5s $fuzzer_path $pre_args $testcase $post_args
  fi

  ec=$?
  if [[ $ec -eq 124 ]]; then
    echo "[TIMEOUT] $name"
  elif [[ $ec -ne 0 ]]; then
    echo "[FAIL] $name (code $ec)"
  else
    echo "[PASS] $name"
  fi

  return 0  # <== Suppress actual exit code
}
export -f run_testcase

# on exit delete unnecessary data

if [ "$COVERAGE_PROFILE" = "true" ] || [ "$ENUMERATION_PROFILE" = "true" ]; then

    if [[ "$ENUMERATION_PROFILE" == "true" ]]; then
      export ENUM_PROFILE_FILE="$FUZZ_OUT/default_enumprofile.csv"
      $OUT/afl-enumetric-dumper-bitmapshared &
      bitmapshared_pid=$!
      echo "Started enumetric bitmap dumper (PID: $bitmapshared_pid)"
      sleep 2
    fi

    if [ "$MULTIDESOCK" = "true" ]; then
      export LD_PRELOAD=/usr/lib/desockmulti.so
    fi

    if [ ! -e "$FUZZ_OUT/llvmcov.json" ] || [ "$ENUMERATION_PROFILE" = "true" ]; then
      if ! find $FUZZ_OUT/default/queue/ -type f | head -n 10 | parallel --halt never run_testcase {} "$STDIN_REDIRECT" "$SUT_ARGS" ; then
        echo "[warn] parallel jobs had failures, but continuing..."
      fi
    else
      echo "Coverage file exists. Skipping test case runs."
    fi

    unset LD_PRELOAD

    if [ "$ENUMERATION_PROFILE" = "true" ]; then
      sleep 2
      kill $bitmapshared_pid
    fi

    if [[ "$COVERAGE_PROFILE" == "true" && ! -e "$FUZZ_OUT/llvmcov_total.json" ]]; then
      echo "Generating merged coverage profile..."

      ls coverage_*.profraw | xargs -n 100 -I {} llvm-profdata-13 merge -sparse {} -o temp_coverage_{}.profdata
      llvm-profdata-13 merge -sparse temp_coverage_*.profdata -o coverage.profdata
      llvm-cov-13 export --format=text --instr-profile ./coverage.profdata $OUT/$FUZZER > $FUZZ_OUT/llvmcov.json
      python3 -c "import sys, json; fdfull = open('$FUZZ_OUT/llvmcov.json', 'r'); data = json.load(fdfull); fdfull.close(); fd = open('$FUZZ_OUT/llvmcov_total.json', 'w+'); json.dump(data['data'][0]['totals'], fd); fd.close()"
    fi
fi

# --- Cleanup and ownership ---

if [[ -d "./default" ]]; then
  cp ./default/fuzzer_stats ./default/plot_data .
fi

chown -R "$OUTUID:$OUTGID" "$FUZZ_OUT"
cd "$FUZZ_OUT"

rm -rf ./default ./queue ./hangs ./crashes ./.synced ./fuzzer_setup ./fuzz_bitmap ./cmdline
rm -f ./coverage_*.profraw ./*.profraw.profdata "$OUT"/coverage_*.profraw "$OUT"/*.profraw.profdata "$OUT"/coverage.profdata

[[ "$SGFUZZ_KIND" -eq 1 ]] && rm -f ../fuzz_out.tar.gz